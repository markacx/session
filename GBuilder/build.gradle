import org.gradle.api.Project
description = 'Root project'

logger.quiet("Java version of build: " + System.getProperty("java.version"))

//If we want to set defaults for our project that our private to us, maybe where our codesign program is, we can put in
//in this file.  I don't put the private.gradle in version control.
File privateFile = new File(projectDir,'private.gradle')
if (privateFile.exists()) {
	apply from: 'private.gradle'
}

ext.myRootDirectory = new File(projectDir,'..').canonicalFile.absolutePath

if (!hasProperty('distributionBase')) {
	//We will use the current directory by default, but we can specifiy this in the private.gradle file and not use the default
	ext.distributionBase = new File(projectDir,'dist').canonicalFile.absolutePath
}
ext.isReleaseBuild = "true".equals(isReleaseBuildText.toLowerCase())
ext.resourcesDir = new File(projectDir,'resources')

apply from: 'lib-def.gradle'

logger.quiet "Base = ${distributionBase}"

subprojects {
	ext.distDir = new File(projectDir,'dist')
	ext.resourceDir = resourcesDir
	
	//Find all tasks that have a compile step, and configure the compiler how we want
	tasks.withType(JavaCompile) {
		options.incremental = true
		options.warnings = false
		options.deprecation = false
		options.fork = true;
		options.forkOptions.with {
			memoryMaximumSize = "512M"
		}
	}
	//Find all tasks that have a Jar task, and configure the jar how we want
	tasks.withType(Jar) {
		metaInf {
			from (resourcesDir) {
				include 'VERSION-INFO.txt'
			}
		}
		manifest {
			attributes (
				'ReleaseBuild': isReleaseBuild,
				//Having BuildTime in the config section will force this task run every time.  Instead, put it in doFirst section
				//'BuildTime': System.currentTimeMillis() 
			)
		}
		doFirst {
			//Doing this prevents a change in the build date from invalidating the jar file and triggering a rebuild
			manifest.attributes ('BuildTime': System.currentTimeMillis())
		}
	}
	//After everything has "evaluated" create a copyToDistribution task if there is not already one.
	afterEvaluate( { Project proj ->
		if (!proj.tasks.matching( {it.name == 'createDist'}).empty) {
			if (proj.tasks.matching( {it.name == 'copyToDistribution'}).empty) {
				proj.task([type: Copy, group : 'Distribution',dependsOn: ':'+proj.name + ':createDist'],"copyToDistribution") {
					from proj.distDir
					into new File(distributionBase)
					doLast {
						println "'Default' copyToDistribution task in project ${project.name}"
					}
				}
			}
			//Whether or not we created a task or not, if the project has a "createDist" task, make sure the root project's
			//"createDist" task depends on it, so we are sure it gets executed
			rootProject.tasks['createDist'].dependsOn += proj.tasks['createDist']
			rootProject.tasks['createDist'].dependsOn += proj.tasks['copyToDistribution']
		}
	})
}
//This will never copy anything because the "configuration" is in the doLast section ( "<<" means doLast)
//To fix, remove the "<<"
task justForShow (type: Copy) << {
	println "Just for show"
	from resourcesDir
	into distributionBase
	include "MyShowFile.txt"
}
//clean is defined in the Java plugin, but not in this file, so we just create a new task called 'clean' here
//Note, that in the viewer.gradle file, which uses the Java plugin, we do our delete in the configure action.
//Here, this is going to extend from default action, meaning that a delete called here will actual do the delete.
//Therefore, we put the delete in a doLast action
task clean {
	doLast {
		delete distributionBase
	}
}
task createDist (dependsOn: [':viewer:createDist',':servlet:createDist',justForShow]) {

}
project(':viewer') {
	ext.projectBase=myRootDirectory+'/Viewer'
}
project(':servlet') {
	ext.projectBase=myRootDirectory+'/Servlet'
}
