import net.ocie.javaone2015.build.fx.*
import net.ocie.javaone2015.build.validation.*
import org.gradle.api.GradleException

apply plugin: 'java'

File copyDir = new File(projectDir,'copyDir')
File packageDir = new File(projectDir,'packageDir')

task validate(description: 'Validate Build User') {
	doFirst {
		//this will open a SSH configuration dialog, in Pure JavaFX.
		//beacause Platform.exit() is the only way to return to the Gradle context
		//we cannot open further javafx dialogs.
		//uncomment out the below line to see this behavior
		//def pureFXConfigOutput = PureFXGetSSHInfo.openWindow("This is the initial config");
		
		//this limitation led us to develop a Swing wrapper for our JavaFX layout
		def fxmlURL = BuildValidationController.class.getResource("buildvalidation.fxml")
		def styleURL = BuildValidationController.class.getResource("buildvalidation.css")
		//we will pass in a string configuration object, and expect a ValidationResponse back
		def window = new FXPanelFrame<String, ValidationResponse>("Validation Config String", fxmlURL, styleURL);
		window.setExtraProperty("title", "Enter the windows keystore password");
		window.show();
		def val = window.getReturnValue();
		if (!val.isValid()) {
			throw new GradleException("Build canceled by user")
		}		
	}
}
task init_distribution << {
	distDir.mkdir()
	copyDir.mkdir()
	packageDir.mkdir()
}
clean {
	delete distDir
	delete copyDir
	delete packageDir
}
//This would not have to be a task.  The createClientTask lines could just be part of the script, but this helps
//me keep everything in order
task init_client (description: 'Create client sub jar tasks') {
	createClientTask('Module1',['com/rebuild/ext/module1/**'])
	createClientTask('Module2',['com/rebuild/ext/module2/**'])
	createClientTask('Module3',['com/rebuild/ext/module3/**'])
	//If modules 4 and 5 are so tied together that they can be bundled as one, we can do this too
	createClientTask('Module4n5',['com/rebuild/ext/module4/**','com/rebuild/ext/module5/**'])

	//We want to make sure these new tasks are executed.  To do that, we need something to depend on them
	//Find all the tasks in the project, find the ones we just created, and make the are class depend on these being done
	tasks.each( {
			logger.info("Examining task " + it)
			if (it.group == 'client_sub_jar') {
				jar.dependsOn += it 
				logger.info("Adding" + it)
			}
		}
	)
}
//This would not have to be a task.  The createServerTask lines could just be part of the script, but this helps
//me keep everything in order
task init_server (description: 'Create server sub jar tasks') {
	createServerTask('Module1',['com/rebuild/ext/module1/**'])
	createServerTask('Module2',['com/rebuild/ext/module2/**'])
	createServerTask('Module3',['com/rebuild/ext/module3/**'])
	//If modules 4 and 5 are so tied together that they can be bundled as one, we can do this too
	createServerTask('Module4n5',['com/rebuild/ext/module4/**','com/rebuild/ext/module5/**'])

	tasks.each( {
			logger.info("Examining task " + it)
			if (it.group == 'server_sub_jar') {
				jar.dependsOn += it 
				logger.info("Adding" + it)
			}
		}
	)
}
compileJava {
	source "$projectBase/src"
	include '**/*.java'
}
processResources {
	from "$projectBase/src"
	exclude '**/*.java'
}
jar {
	archiveName = 'MyApp.jar'
	//The module files are in other jar files, so exclude them from this one
	include 'com/rebuild/app/viewer/**'
	include 'com/rebuild/client/**'
}
task copyStuff(type: Copy) {
	from resourcesDir
	into copyDir
	include 'README.txt'
	include 'picture.png'

	doLast {
		ant.fixcrlf (eol:"lf", srcdir : destinationDir, includes: 'README.txt')
	}
}
task execJava (type: Exec, dependsOn : [compileJava,init_distribution]) {
	def file = new File(packageDir,"version.txt")
	println "PACKAGE: "+ packageDir
	executable System.getProperty("java.home") + "/bin/java.exe"
	args "-version"
	
	//The arguments and executable are not considered part of the "inputs"  
	//Add them explicitly if a change in them should re-run the task
	inputs.property('MyArgs',args)
	inputs.property('MyExecutable',executable)
	
	//Without setting an output, the task not have any output and so will run every time
	outputs.file(file)
	
	doFirst {
		//Running java with the -version option outputs the the version information to standard error
		errorOutput new ByteArrayOutputStream()
	}
	doLast {
		file.text = errorOutput.toString()
	}
}
task makePackage (description : 'Put files in zip file', type: Zip, dependsOn: [jar,init_distribution,copyStuff,execJava]) {
	archiveName = "package.zip"
	def subTasks = tasks.matching( { task -> task.group == 'client_sub_jar' } )
	from subTasks
}
//This rename moves the file from the output of makePackage, forcing it to re-run every time
task copyPackage_bad (description : 'Do something to the zip file', dependsOn: makePackage) {
	def org = makePackage.outputs.getFiles()[0];
	org.renameTo(packageDir)
} 
task copyPackage (type : Copy, description : 'Do something to the zip file', dependsOn: makePackage) {
	from makePackage
	into packageDir
} 
task createDist (type: Copy, dependsOn: [execJava,jar,copyPackage]) {
	from copyPackage
	into distDir
}

task copyBigFile << {
	println "Copying big file"
}
task copyToDistribution (type: Copy, dependsOn: [copyBigFile, createDist]) {
	from createDist
	into new File(rootProject.distributionBase)
	doLast {
		println "'Overridden' copyToDistribution task in ${project.name}"
	}
}
public void createClientTask(archive,dirs) {
	task([type: Jar, group : 'client_sub_jar', dependsOn:"compileJava"],"create_viewer_" + archive) {
		from sourceSets.main.output

		includes = dirs
		exclude "**/server/**"
		archiveName ="${archive}C.jar"
		artifacts {
			archives file: new File(buildDir,archiveName), name: archive, type: 'jar', classifier: 'extra'
		}
	}
	tasks.jar.dependsOn += "create_viewer_" + archive
}
public void createServerTask(archive,dirs) {
	task([type: Jar, group : 'server_sub_jar', dependsOn:"compileJava"],"create_server_" + archive) {
		from sourceSets.main.output

		includes = dirs
		exclude "**/client/**"
		archiveName ="${archive}S.jar"
		artifacts {
			archives file: new File(buildDir,archiveName), name: archive, type: 'jar', classifier: 'extra'
		}
	}
	tasks.jar.dependsOn += "create_server_" + archive
}